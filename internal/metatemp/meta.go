/**
 * @Author:  jager
 * @Email:   lhj168os@gmail.com
 * @File:    meta
 * @Date:    2022/3/8 5:38 下午
 * @package: template
 * @Version: v1.0.0
 *
 * @Description:
 *
 */

package metatemp

import (
	"errors"
	"fmt"
	"log"
	"strings"
)

func Head(fileName, pbPkg, sessPkg string) string {
	head := `// Code generated by metactl. DO NOT EDIT.
// source: %s

package meta

import (
	"errors"

	sess "%s"

	pb "%s"	
)
`
	return fmt.Sprintf(head, fileName, sessPkg, pbPkg)
}

func metaHandle(req, resp string) string {
	if req == "" || req == "nil" || req == "null" {
		if resp == "" || resp == "nil" || resp == "null" {
			return "func(ss sess.ISession) (err error)"
		} else {
			return fmt.Sprintf("func(ss sess.ISession) (resp *pb.%s, err error)", resp)
		}
	} else if resp == "" || resp == "nil" || resp == "null" {
		return fmt.Sprintf("func(ss sess.ISession, arg *pb.%s) (err error)", req)
	} else {
		return fmt.Sprintf("func(ss sess.ISession, arg *pb.%s) (resp *pb.%s, err error)", req, resp)
	}
}

func metaHandleFunc(req, resp string) string {
	if req == "" || req == "nil" || req == "null" {
		if resp == "" || resp == "nil" || resp == "null" {
			return "nil, m.handleFn(ss)"
		} else {
			return "m.handleFn(ss)"
		}
	} else if resp == "" || resp == "nil" || resp == "null" {
		return fmt.Sprintf("nil, m.handleFn(ss, arg.(*pb.%s))", req)
	} else {
		return fmt.Sprintf("m.handleFn(ss, arg.(*pb.%s))", req)
	}
}

func MetaStruct(note, enum, msgId, req, resp string) string {
	f := metaHandle(req, resp)
	metaStruct := `
%s
//------------------------------------------------------------------------------------------

var %s = &meta_%s{}

// implement IMeta

type meta_%s struct {
	handleFn %s
}

func (m *meta_%s) RegistryHandle(f %s) {
	m.handleFn = f
	registerMeta(m)
}

func (m *meta_%s) handle(ss sess.ISession, arg interface{}) (interface{}, error) {
	return %s
}

func (m *meta_%s) getMsgID() pb.%s {
	return pb.%s_%s
}
`
	handleContent := metaHandleFunc(req, resp)
	return fmt.Sprintf(metaStruct, note, msgId, msgId, msgId, f, msgId, f, msgId, handleContent, msgId, enum, enum, msgId)
}

func EncodeArg(msgId, req string) string {
	if req == "nil" || req == "" || req == "null" {
		return fmt.Sprintf(`
func (m *meta_%s) encodeArg(arg interface{}) ([]byte, error) {
		return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *meta_%s) encodeArg(arg interface{}) ([]byte, error) {
	_arg, ok := arg.(*pb.%s)
	if !ok {
		p, ok := arg.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("%s_meta EncodeArg error type")
	}

	return _arg.Marshal()
}
`, msgId, req, msgId)
}

func DecodeArg(msgId, req string) string {
	if req == "nil" || req == "" || req == "null" {
		return fmt.Sprintf(`
func (m *meta_%s) decodeArg(data []byte) (interface{}, error) {
	return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *meta_%s) decodeArg(data []byte) (interface{}, error) {
	arg := &pb.%s{}
	if err := arg.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return arg, nil
	}
}
`, msgId, req)
}

func EncodeReply(msgId, resp string) string {
	if resp == "" || resp == "nil" || resp == "null" || resp == "ok" {
		return fmt.Sprintf(`
func (m *meta_%s) encodeReply(reply interface{}) ([]byte, error) {
	return nil, nil
}
`, msgId)
	}
	return fmt.Sprintf(`
func (m *meta_%s) encodeReply(reply interface{}) ([]byte, error) {
	_reply, ok := reply.(*pb.%s)
	if !ok {
		p, ok := reply.([]byte)
		if ok {
			return p, nil
		}

		return nil, errors.New("%s_meta EncodeReply error type")
	}

	return _reply.Marshal()
}
`, msgId, resp, msgId)
}

func DecodeReply(msgId, resp string) string {
	if resp == "" || resp == "nil" || resp == "null" || resp == "ok" {
		return fmt.Sprintf(`
func (m *meta_%s) decodeReply(data []byte) (interface{}, error) {
	return nil, nil
}
`, msgId)
	}

	return fmt.Sprintf(`
func (m *meta_%s) decodeReply(data []byte) (interface{}, error) {
	reply := &pb.%s{}
	if err := reply.Unmarshal(data); err != nil {
		return nil, err
	} else {
		return reply, nil
	}
}
`, msgId, resp)
}

func End(msgId string) string {
	return fmt.Sprintf("\n// ================== %s End ==================\n\n", msgId)
}

func GenMeta(enumName, notes, msgid, req, resp string) string {
	code := MetaStruct(notes, enumName, msgid, req, resp)
	code += EncodeArg(msgid, req)
	code += DecodeArg(msgid, req)
	code += EncodeReply(msgid, resp)
	code += DecodeReply(msgid, resp)
	code += End(msgid)
	return code
}

func splitByExtraSpace(str string) []string {
	str = strings.Replace(str, "\t", " ", -1)
	ss := strings.Split(str, " ")
	var sss []string
	for _, s := range ss {
		if s != "" {
			sss = append(sss, s)
		}
	}
	return sss
}

func GenMetaFile(fileName, pbPkg, sessPkg, enumName string, rpcInfos []string) (string, []string, error) {
	if len(rpcInfos) <= 0 {
		return "", nil, errors.New("not has rpc info")
	}
	result := Head(fileName, pbPkg, sessPkg)
	var allMsgId []string
	for _, ri := range rpcInfos {
		if strings.Contains(ri, "//@") {
			log.Printf("[Parse] RpcComment: %s", ri)
			strs := splitByExtraSpace(ri)
			var msgid, req, resp string
			for i := 0; i+1 < len(strs); i += 2 {
				switch strs[i] {
				case "//@":
					msgid = strs[i+1]
				case "req:":
					if strs[i] != "resp:" && !strings.HasPrefix(strs[i], "//") {
						req = strs[i+1]
					}
				case "resp:":
					if strs[i] != "req:" && !strings.HasPrefix(strs[i], "//") {
						resp = strs[i+1]
					}
				}
			}
			note := strings.Join(strs, " ")
			result += GenMeta(enumName, note, msgid, req, resp)
			allMsgId = append(allMsgId, msgid)
		}
	}
	if len(allMsgId) <= 0 {
		return "", nil, errors.New("not has right rpc info")
	}
	return result, allMsgId, nil
}

func GenMetaRegister(msgids []string, source string) string {
	source = strings.Replace(source+"/*.proto", "//", "/", -1)
	code := fmt.Sprintf(`// Code generated by metactl. DO NOT EDIT.
// source: %s

package meta

func init()  {
`, source)

	for _, msgid := range msgids {
		code += fmt.Sprintf("	registerMeta(%s)\n", msgid)
	}

	code += "}"
	return code
}
